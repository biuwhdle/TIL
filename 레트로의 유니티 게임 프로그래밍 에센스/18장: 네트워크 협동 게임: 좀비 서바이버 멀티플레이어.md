## 레트로의 유니티 게임 프로그래밍 에센스

18장: 좀비 서바이버 멀티플레이어: 네트워크 이론과 로비 구현

#### 네트워크 동기화

- 클라이언트: 서버에 접속하여 서비스를 제공받은 단말기, 프로그램, 사용자
- 동기화
  - 클라이언트 A의 플레이어 캐릭터 a와 클라이언트 B의 플레이어 캐릭터 a는 서로 다른 게임 오브젝트
  - 네트워크 관리자는 이 둘에 동일한 식별자 부여
  - 네트워크에 연결된 동안 서로 동일한 상태를 유지, 네트워크 연결이 끊기면 서로 완전히 다른 존재
  - 동기화 간격이 길거나 인터넷 속도가 느림 -> 각 게임 월드의 모습이 조금씩 달라질 수 있음
  - 네트워크 접속이 끊김 -> 게임 월드는 서로 완전히 독립적으로 동작
- 로컬: 물리적으로 사용자의 위치에 존재하는 단말기나 프로그램, 오브젝트
  - ex. 로컬 데스크톱: 사용자가 직접 사용 중인 컴퓨터
- 리모트: 원격 접속을 통해 접근할 수 있는 단말기나 프로그램, 오브젝트
  - ex. 리모트 데스크톱: 인터넷 등을 통해 접속한 타인의 컴퓨터
- 로컬과 리모트를 나누는 기준: 해당 게임 오브젝트의 주도권
  - 로컬 오브젝트: 로컬 클라이언트의 게임 월드에서 생성. 주도권은 로컬 클라이언트에 있음
  - 리모트 오브젝트: 타인의 게임 월드에서 생성, 네트워크를 통해 복제 생성. 주도권이 네트워크 너머의 타인에게 있음
  - 특별한 경우를 제외, 로컬 클라이언트가 리모트 오브젝트를 임의로 삭제하거나 주요 상태를 변경할 수 없음
- 로컬과 리모트 플레이어 캐릭터 모두 사용자 입력을 받을 수 있는 문제
  - 오브젝트가 로컬 권한을 가지고 잇는지 검사 -> 리모트 플레이어 캐릭터에 반영되지 않도록 함
 
#### 게임 서버의 종류

- 네트워크 기반 게임은 서버-클라이언트 방식으로 동작
  - 서버-클라이언트: 대기 중인 서버에 클라이언트들이 참가
- 서버: 클라이언트들이 참가할 수 있는 네트워크 공간 (=호스트)
  - 게임 속 상호작용 연산도 담당
- 클라이언트: 서버에 참가해 게임을 플레이하는 컴퓨터
- 서버의 구현 방식
  - 전용 서버(Dedicated Server)
    - 서버의 모든 자원이 온전히 네트워크 서비스를 유지하는 데 사용
    - 서버가 플레이어로서 게임에 직접 참가하지 않음
    - 장점
      - 클라이언트는 언제든 참가 가능
      - 고정된 고성능 서버를 제공 -> 쾌적한 환경에서 게임 즐길 수 있음
    - 단점
      - 고정비용이 많이 발생
  - 리슨 서버(Listen Server)
    - 플레이어 클라이언트 중 하나가 서버 역할을 맡음
    - 리슨 서버는 게임에 플레이어로 참가 (Play as Host)
    - 서버 역할을 맡은 클라이언트: 방장, 호스트, 마스터 클라이언트 등
    - 장점
      - 전용 서버보다 서비스 유지비용이 적음
      - 물리적으로 가까운 위치에 있는 플레이어들끼리 네트워크 반응 속도가 빠름
    - 단점
      - 호스트 플레이어의 컴퓨터 성능에 따라 네트워크 품질 달라짐
      - 호스트가 게임을 종료할 경우 진행 중인 게임을 일시 정지, 남은 클라이언트 중 새로운 호스트를 선정 (Host Migration)
  - P2P(Peer-to-Peer)
    - 게임에 참가한 클라이언트 모두가 호스트 역할을 겸함
    - 클라이언트들이 서로 직접 연결된 형태
    - 연산 대부분을 독점하는 특정 호스트가 없음. 각자 자신의 월드에서 자신의 담당 연산을 실행, 다른 클라이언트에 결과 전파
    - 장점
      - Host Migration이 불필요
      - 서버 유지비용이 발생하지 않음
      - 클라이언트 수가 적은 경우, 네트워크 반응 속도가 빠름
      - 개발자는 프로그램의 처리 흐름을 직관적으로 설계 가능
    - 단점
      - 참가자가 증가할수록 반응 속도 느려짐 (16명이 참가자 상한선)
      - 연결수가 늘어날수록 각 클라이언트가 부담하게 되는 연산양이 빠르게 증가 -> 호스트-클라이언트 방식의 호스트보다 많은 연산 부담
      - 수치 변조에 취약 (특정 중요 수치를 위조해 다른 클라이언트에 전파할 위험 큼)
- 포톤 룸
  - 여러 클라이언트가 모인 네트워크상의 가상 공간
  - 유니티의 씬이 아님 -> 플레이어들이 서로 다른 씬을 로드하는 것도 가능
 
#### 네트워크 권한 분리

- 중요한 연산은 모두 서버에 위임해야 함
  - 동기화에 오차가 존재하는 경우 기준이 되는 월드를 정하기 위함
    - 네트워크 동기화는 전송 속도나 패킷 손실이라는 현실 문제 -> 클라이언트마다 오차가 존재할 수 있음
    - 동일한 행위에 대한 결과가 각 클라이언트마다 다를 경우 어떤 결과를 따라야 하는지 결정할 수 없음
  - 클라이언트의 변조나 위조 행위를 막기 위함
    - 특정 클라이언트의 비정상적인 행위나 수치 변조가 네트워크를 넘어 다른 클라이언트에 그대로 적용될 수 있음
- 중요한 연산은 호스트의 게임 월드에서 실행, 결과를 다른 클라이언트가 따름
  - 모든 처리와 수치의 기준은 호스트의 게임 월드
  - 게임의 승패와 직접적인 관련이 있는 중요한 처리는 호스트에 위임
  - 클라이언트는 호스트의 결과를 받아들이고, 시각적 처리(비주얼 이펙트, 효과음 재생, 애니메이션 재생 등)만 수행
- RPC(remote procedure call, 원격 프로시저 호출)
  - 어떤 메서드나 처리를 네트워크를 넘어 다른 클라이언트에서 실행
  - 호스트에 처리를 위임하고, 호스트가 처리 결과를 클라이언트에 전파하기 위함
 
#### UNet과 포톤

- UNet: 유니티에 기본 내장된 공식 라이브러리
  - 2018.3 버전부터 Deprecated로 선언
- 포톤: 다양한 플랫폼과 게임 엔진을 지원하는 네트워크 종합 솔루션
  - 클라우드 서버 대여 서비스, 실시간으로 게임 서버를 관리할 수 있는 웹 서비스, 여러 게임 엔진에 플러그인 형태로 삽입할 수 있는 네트워크 엔진 등 제공
  - PUN(Photon Unity Network): 유니티용으로 제작된 포톤 네트워크 엔진
    - 포톤의 여러 API를 유니티 컴포넌트로 랩핑하여 제공 -> 게임 오브젝트에 컴포넌트로 추가 가능
  - 서비스는 포톤 클라우드 서버를 경유해 제공, 개발자용 AppID를 지급받아야 사용 가능

#### PUN

- Photon.Pun: 여러 포톤 C# 라이브러리를 유니티 게임 오브젝트와 컴포넌트로 사용할 수 있게 하는 PUN 라이브러리
- Photon.Realtime: 포톤의 실시간 네트워크 게임 개발용 C# 라이브러리
- MonoBehaviourPunCallbacks: MonoBehaviour를 확장한 클래스
  - MonoBehaviour의 기능 유지, 컴포넌트가 포톤 서비스에 의해 발생하는 콜백도 감지할 수 있게 함
- PhotonNetwork
  - PhotonNetwork.GameVersion: 게임 버전 설정
  - PhotonNetwork.IsConnected: 접속 상태
  - PhotonNetwork.ConnectUsingSettings(): 마스터 서버에 접속 시도
  - PhotonNetwork.JoinRandomRoom(): 랜덤 룸으로 접속 시도
  - PhotonNetwork.CreateRoom(string name, new RoomOptions): 새로운 룸 생성
    - 생성할 룸의 이름을 string 타입으로, 생성할 룸의 옵션을 RoomOptions 타입으로 입력
    - ex. new RoomOptions {MaxPlayers = 4}는 최대 수용 인원을 4명으로 제한한 것
    - 룸은 리슨 서버 방식으로 동작. 룸을 생성한 클라이언트가 호스트 역할
  - PhotonNetwork.LoadLevel(): 어떤 씬을 로드, 해당 씬의 구성이 플레이어 사이에서 동기화되도록 유지
    - 호스트가 실행하면 다른 플레이어들의 컴퓨터에서도 자도으로 실행, 같은 씬 로드
    - 도중에 참가한 플레이어에게도 해당 씬의 모습이 다른 플레이어들이 보는 씬의 모습과 동일하게 자동 구성
    - cf. SceneManager.LoadScene(): 네트워크 정보가 유지되지 않음. 서로 동기화 없이 씬을 로드함 -> 다른 사람의 캐릭터가 안 보임
- 포톤 전용 이벤트: override를 사용해 구현해야 함
  - OnConnectedToMaster(): 포톤 마스터 서버에 접속 성공한 경우 자동 실행
  - OnDisconnected(): 마스터 서버에 접속 실패했거나 이미 마스터 서버에 접속된 상태에서 접속이 끊긴 경우 자동 실행
    - DisconnectCause 타입: 접속 끊김의 원인에 대한 정보가 자동 입력됨
  - OnJoinRandomField(): 랜덤 룸 접속에 실패한 경우 자동 실행
    - 마스터 서버와의 연결이 끊긴 건 아님
    - 참가 가능한 랜덤 룸이 없는 경우 발생
  - OnJoinedRoom(): 룸 참가에 성공한 경우 자동 실행
    - CreateRoom()으로 직접 룸을 생성하고 참가한 경우에도 실행
